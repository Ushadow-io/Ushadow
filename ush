#!/usr/bin/env python3
"""
ush - ushadow Command Line Tool

Dynamic CLI that auto-discovers commands from OpenAPI spec.
All API endpoints are automatically available as CLI commands.

Examples:
    ush                              # List all command groups
    ush services                     # List services commands
    ush services list                # GET /api/services/
    ush services start chronicle     # POST /api/services/{name}/start
    ush providers list               # GET /api/providers/
    ush wizard quickstart            # GET /api/wizard/quickstart
"""

import json
import os
import re
import sys
from pathlib import Path
from typing import Any, Optional

from rich.console import Console
from rich.table import Table

# Shell mode imports (lazy loaded)
SHELL_AVAILABLE = True
try:
    from prompt_toolkit import PromptSession
    from prompt_toolkit.auto_suggest import AutoSuggestFromHistory
    from prompt_toolkit.completion import Completer, Completion
    from prompt_toolkit.history import FileHistory
    from prompt_toolkit.styles import Style
    from prompt_toolkit.key_binding import KeyBindings
except ImportError:
    SHELL_AVAILABLE = False

# Add project root to path
PROJECT_ROOT = Path(__file__).parent
sys.path.insert(0, str(PROJECT_ROOT))

from ushadow.client import UshadowClient

console = Console()

# =============================================================================
# OpenAPI Spec Loader
# =============================================================================

def load_openapi_spec() -> dict:
    """Load OpenAPI spec from file or fetch from server."""
    spec_file = PROJECT_ROOT / "openapi.json"

    if spec_file.exists():
        with open(spec_file) as f:
            return json.load(f)

    # Try to fetch from server
    try:
        client = UshadowClient.from_env()
        return client.api("GET", "/openapi.json", auth=False)
    except Exception:
        console.print("[red]‚ùå No openapi.json found. Run: curl http://localhost:8000/openapi.json > openapi.json[/red]")
        sys.exit(1)


def parse_endpoints(spec: dict) -> dict[str, dict]:
    """
    Parse OpenAPI spec into a command structure.

    Returns:
        {
            "services": {
                "list": {"method": "GET", "path": "/api/services/", "summary": "...", "params": []},
                "start": {"method": "POST", "path": "/api/services/{name}/start", "params": ["name"]},
                ...
            },
            "providers": {...},
            ...
        }
    """
    commands = {}

    for path, methods in spec.get("paths", {}).items():
        for method, details in methods.items():
            if method not in ("get", "post", "put", "delete"):
                continue

            # Extract tag (command group)
            tags = details.get("tags", ["default"])
            tag = tags[0] if tags else "default"

            # Skip auth endpoints (handled separately)
            if tag == "auth":
                continue

            # Parse command name from path
            # /api/services/{name}/start -> "start"
            # /api/services/ -> "list"
            # /api/services/{name} -> "get"
            cmd_name = extract_command_name(path, method)

            # Extract parameters
            params = details.get("parameters", [])
            path_params = [p["name"] for p in params if p.get("in") == "path"]
            query_params = [
                {
                    "name": p["name"],
                    "required": p.get("required", False),
                    "description": p.get("description", ""),
                    "type": p.get("schema", {}).get("type", "string"),
                    "default": p.get("schema", {}).get("default"),
                }
                for p in params if p.get("in") == "query"
            ]

            # Check if request body is required
            has_body = "requestBody" in details

            # Build command entry
            if tag not in commands:
                commands[tag] = {}

            commands[tag][cmd_name] = {
                "method": method.upper(),
                "path": path,
                "summary": details.get("summary", ""),
                "description": details.get("description", ""),
                "path_params": path_params,
                "query_params": query_params,
                "has_body": has_body,
                "requires_auth": requires_auth(details),
            }

    return commands


def extract_command_name(path: str, method: str) -> str:
    """
    Extract a clean command name from path and method.

    /api/services/ + GET -> list
    /api/services/{name} + GET -> get
    /api/services/{name}/start + POST -> start
    /api/services/{name}/logs + GET -> logs
    /api/services/catalog + GET -> catalog
    """
    # Remove /api/ prefix and tag
    parts = path.strip("/").split("/")
    if parts[0] == "api":
        parts = parts[1:]
    if parts:
        parts = parts[1:]  # Remove tag (services, providers, etc.)

    # Handle empty path (list endpoint)
    if not parts:
        return "list"

    # Filter out path parameters
    parts = [p for p in parts if not p.startswith("{")]

    if not parts:
        # Path was just /{param} - this is a "get" operation
        return "get" if method == "get" else method

    # Join remaining parts with hyphens
    name = "-".join(parts)

    # Special case: if it's just the tag + method, use method name
    if not name:
        name = "get" if method == "get" else method

    return name


def requires_auth(endpoint_details: dict) -> bool:
    """Check if endpoint requires authentication."""
    security = endpoint_details.get("security", [])
    # If security is empty list, it's explicitly public
    # If security is not present, check global security
    return len(security) > 0 or "security" not in endpoint_details


# =============================================================================
# Output Formatters (for pretty output on specific commands)
# =============================================================================

def format_services_list(data: list) -> None:
    """Pretty format for services list."""
    table = Table(title="Services", show_header=True, header_style="bold magenta")
    table.add_column("Name", style="cyan", width=25)
    table.add_column("Status", width=20)
    table.add_column("Installed", width=10)
    table.add_column("Description", overflow="fold")

    for svc in data:
        status = svc.get("status", "unknown")
        health = svc.get("health")

        if status == "running":
            status_str = f"üü¢ {status}" if health == "healthy" else f"üü° {status}"
        elif status in ("stopped", "not_found", "exited"):
            status_str = f"üî¥ {status}"
        else:
            status_str = f"‚ö™ {status}"

        installed = "‚úÖ" if svc.get("installed") else "‚ùå"
        desc = (svc.get("description") or "")[:40]

        table.add_row(svc.get("service_name", "?"), status_str, installed, desc)

    console.print(table)


def format_providers_list(data: list) -> None:
    """Pretty format for providers list."""
    table = Table(title="Providers", show_header=True, header_style="bold magenta")
    table.add_column("ID", style="cyan", width=15)
    table.add_column("Name", width=20)
    table.add_column("Capability", width=15)

    for p in data:
        table.add_row(
            p.get("id", "?"),
            p.get("name", "?"),
            p.get("capability", "?"),
        )

    console.print(table)


# Registry of custom formatters: (tag, command) -> formatter function
FORMATTERS = {
    ("services", "list"): format_services_list,
    ("providers", "list"): format_providers_list,
}


# =============================================================================
# CLI Execution
# =============================================================================

def execute_command(
    client: UshadowClient,
    cmd_info: dict,
    path_args: dict[str, str],
    query_args: dict[str, Any],
    body_data: Optional[dict],
    tag: str,
    cmd_name: str,
) -> Any:
    """Execute an API command and return the result."""
    # Build the path with substituted parameters
    path = cmd_info["path"]
    for param, value in path_args.items():
        path = path.replace(f"{{{param}}}", value)

    # Add query parameters
    if query_args:
        query_str = "&".join(f"{k}={v}" for k, v in query_args.items() if v is not None)
        if query_str:
            path = f"{path}?{query_str}"

    # Make the request
    result = client.api(
        cmd_info["method"],
        path,
        data=body_data,
        auth=cmd_info["requires_auth"],
    )

    return result


def print_result(result: Any, tag: str, cmd_name: str) -> None:
    """Print the result, using custom formatter if available."""
    formatter = FORMATTERS.get((tag, cmd_name))

    if formatter and isinstance(result, list):
        formatter(result)
    elif isinstance(result, dict) and result.get("success") is not None:
        # Action result
        if result.get("success"):
            console.print(f"[green]‚úÖ {result.get('message', 'Success')}[/green]")
        else:
            console.print(f"[red]‚ùå {result.get('message', 'Failed')}[/red]")
    else:
        # Default: JSON output
        console.print(json.dumps(result, indent=2))


def show_help(commands: dict, tag: Optional[str] = None) -> None:
    """Show help for available commands."""
    if tag is None:
        # Show all command groups
        console.print("\n[bold]ushadow CLI[/bold] - Auto-generated from OpenAPI\n")
        console.print("[bold]Command Groups:[/bold]")
        for group in sorted(commands.keys()):
            cmd_count = len(commands[group])
            console.print(f"  [cyan]{group:<20}[/cyan] ({cmd_count} commands)")
        console.print("\n[dim]Usage: ush <group> <command> [args...][/dim]")
        console.print("[dim]       ush <group> --help[/dim]")
        console.print("[dim]       ush shell              # Interactive mode with Tab completion[/dim]")
        console.print("[dim]       ush health[/dim]")
    else:
        # Show commands for a specific group
        if tag not in commands:
            console.print(f"[red]Unknown command group: {tag}[/red]")
            console.print(f"[dim]Available: {', '.join(sorted(commands.keys()))}[/dim]")
            sys.exit(1)

        console.print(f"\n[bold]{tag}[/bold] commands:\n")
        for cmd_name, cmd_info in sorted(commands[tag].items()):
            params_str = " ".join(f"<{p}>" for p in cmd_info["path_params"])
            opts_str = " ".join(f"[--{p['name']}]" for p in cmd_info["query_params"])

            full_cmd = f"{cmd_name}"
            if params_str:
                full_cmd += f" {params_str}"
            if opts_str:
                full_cmd += f" {opts_str}"

            console.print(f"  [cyan]{full_cmd:<40}[/cyan] {cmd_info['summary']}")

        console.print(f"\n[dim]Usage: ush {tag} <command> [args...][/dim]")


# =============================================================================
# Interactive Shell Mode
# =============================================================================

def get_resource_endpoints() -> dict[str, tuple[str, str]]:
    """
    Map command groups to their list endpoints and name fields.

    Returns dict of: group -> (list_endpoint, name_field)

    This tells the completer how to fetch resource names for each group.
    For example, "services" fetches from "/api/services/" and uses "service_name".

    TODO: Add more mappings as needed for your API groups.
    """
    return {
        "services": ("/api/services/", "service_name"),
        "providers": ("/api/providers/", "id"),
        "instances": ("/api/instances/", "name"),
        "unodes": ("/api/unodes/", "name"),
        "deployments": ("/api/deployments/", "name"),
        # Add more as needed...
    }


class UshCompleter(Completer):
    """
    Nested completer for ush shell with resource-first completion.

    Tab 1: Complete command group (services, providers, etc.)
    Tab 2: Complete resource name OR command (fetched from API)
    Tab 3: Complete command for that resource, or parameters

    Example flow:
        services <Tab>     ‚Üí shows: mem0, chronicle, ... AND list, catalog, ...
        services mem0 <Tab> ‚Üí shows: start, stop, logs, status, ...
    """

    def __init__(self, commands: dict, client: "UshadowClient"):
        self.commands = commands
        self.client = client
        self.special_commands = {"help", "exit", "quit", "health"}

        # Cache for resource lists: {"services": ["mem0", "chronicle", ...]}
        self._resource_cache: dict[str, list[str]] = {}

        # Map: group -> (list_endpoint, name_field)
        # This defines how to fetch resource names for each group
        self.resource_endpoints = get_resource_endpoints()

    def _get_resources(self, group: str) -> list[str]:
        """Fetch and cache resource names for a group."""
        if group in self._resource_cache:
            return self._resource_cache[group]

        if group not in self.resource_endpoints:
            return []

        endpoint, name_field = self.resource_endpoints[group]
        try:
            result = self.client.api("GET", endpoint, auth=True)
            if isinstance(result, list):
                names = [item.get(name_field, "") for item in result if item.get(name_field)]
                self._resource_cache[group] = names
                return names
        except Exception:
            pass  # Silently fail - just won't have completions

        return []

    def _get_commands_for_resource(self, group: str) -> list[str]:
        """Get commands that operate on a specific resource (have path params)."""
        if group not in self.commands:
            return []
        return [
            cmd for cmd, info in self.commands[group].items()
            if info.get("path_params")  # Commands that take a resource name
        ]

    def _get_standalone_commands(self, group: str) -> list[str]:
        """Get commands that don't need a resource (list, catalog, etc.)."""
        if group not in self.commands:
            return []
        return [
            cmd for cmd, info in self.commands[group].items()
            if not info.get("path_params")  # Commands without path params
        ]

    def get_completions(self, document, complete_event):
        text = document.text_before_cursor
        words = text.split()
        word_count = len(words)

        # Handle partial word at cursor
        word_before_cursor = document.get_word_before_cursor()

        # Key fix: if text ends with space, we're completing a NEW word
        at_new_word = text.endswith(" ") or text == ""
        if not at_new_word and words:
            word_count -= 1

        if word_count == 0:
            # === Position 1: Command groups + special commands ===
            for cmd in sorted(self.special_commands):
                if cmd.startswith(word_before_cursor):
                    yield Completion(cmd, start_position=-len(word_before_cursor),
                                   display_meta="built-in")
            for group in sorted(self.commands.keys()):
                if group.startswith(word_before_cursor):
                    cmd_count = len(self.commands[group])
                    yield Completion(group, start_position=-len(word_before_cursor),
                                   display_meta=f"{cmd_count} commands")

        elif word_count == 1:
            # === Position 2: Resources AND standalone commands ===
            # e.g., "services <Tab>" shows: mem0, chronicle, ... AND list, catalog
            group = words[0]
            if group not in self.commands:
                return

            # First: standalone commands (list, catalog, etc.)
            for cmd in sorted(self._get_standalone_commands(group)):
                if cmd.startswith(word_before_cursor):
                    cmd_info = self.commands[group][cmd]
                    yield Completion(cmd, start_position=-len(word_before_cursor),
                                   display_meta=cmd_info.get("summary", "")[:40])

            # Then: resource names from API
            for name in sorted(self._get_resources(group)):
                if name.startswith(word_before_cursor):
                    yield Completion(name, start_position=-len(word_before_cursor),
                                   display_meta="resource")

        elif word_count == 2:
            # === Position 3: Depends on what position 2 was ===
            group = words[0]
            second = words[1]

            if group not in self.commands:
                return

            resources = self._get_resources(group)

            if second in resources:
                # User selected a resource ‚Üí show commands for it
                for cmd in sorted(self._get_commands_for_resource(group)):
                    if cmd.startswith(word_before_cursor):
                        cmd_info = self.commands[group][cmd]
                        yield Completion(cmd, start_position=-len(word_before_cursor),
                                       display_meta=cmd_info.get("summary", "")[:40])
            elif second in self.commands[group]:
                # User selected a command ‚Üí show path params or resources
                cmd_info = self.commands[group][second]
                path_params = cmd_info.get("path_params", [])
                if path_params:
                    # Show resources as completions for the first path param
                    for name in sorted(resources):
                        if name.startswith(word_before_cursor):
                            yield Completion(name, start_position=-len(word_before_cursor),
                                           display_meta=f"<{path_params[0]}>")

        elif word_count >= 3:
            # === Position 4+: Additional params or query params ===
            group = words[0]
            second = words[1]
            third = words[2]

            if group not in self.commands:
                return

            resources = self._get_resources(group)

            # Determine the command and resource
            if second in resources and third in self.commands[group]:
                # Pattern: services mem0 start [additional params]
                cmd_info = self.commands[group][third]
                provided_count = word_count - 3
            elif second in self.commands[group]:
                # Pattern: services start mem0 [additional params]
                cmd_info = self.commands[group][second]
                provided_count = word_count - 3
            else:
                return

            # Query parameters
            for qp in cmd_info.get("query_params", []):
                opt = f"--{qp['name']}"
                if opt.startswith(word_before_cursor) and opt not in words:
                    meta = qp.get("description", "")[:30] or ("required" if qp.get("required") else "optional")
                    yield Completion(opt, start_position=-len(word_before_cursor),
                                   display_meta=meta)


def run_shell(commands: dict, client: UshadowClient) -> None:
    """Run interactive shell with nested completion and fish-style suggestions."""
    if not SHELL_AVAILABLE:
        console.print("[red]Shell mode requires prompt_toolkit. Install with:[/red]")
        console.print("[dim]  pip install prompt_toolkit[/dim]")
        sys.exit(1)

    # Shell styling - includes completion menu styling
    style = Style.from_dict({
        "prompt": "cyan bold",
        "": "#ffffff",
        # Completion menu styling
        "completion-menu": "bg:#333333 #ffffff",
        "completion-menu.completion": "bg:#333333 #ffffff",
        "completion-menu.completion.current": "bg:#00aa00 #000000",
        "completion-menu.meta.completion": "bg:#444444 #aaaaaa",
        "completion-menu.meta.completion.current": "bg:#00aa00 #000000",
    })

    # History file
    history_file = Path.home() / ".ush_history"

    # Create session with completion and history
    # reserve_space_for_menu pushes prompt up so menu is visible at bottom of screen
    session = PromptSession(
        completer=UshCompleter(commands, client),
        auto_suggest=AutoSuggestFromHistory(),
        history=FileHistory(str(history_file)),
        style=style,
        complete_while_typing=False,
        complete_in_thread=True,
        reserve_space_for_menu=8,
    )

    console.print("\n[bold cyan]ushadow shell[/bold cyan] - Type commands, Tab to complete, ‚Üë/‚Üì for history")
    console.print("[dim]Type 'help' for commands, 'exit' to quit[/dim]\n")

    while True:
        try:
            # Get input with completion
            text = session.prompt("ushadow> ").strip()

            if not text:
                continue

            # Handle special commands
            if text in ("exit", "quit"):
                console.print("[dim]Goodbye![/dim]")
                break

            if text == "help":
                show_help(commands)
                continue

            if text == "health":
                try:
                    result = client.health()
                    console.print("[green]‚úÖ ushadow backend healthy[/green]")
                except Exception as e:
                    console.print(f"[red]‚ùå Backend unreachable: {e}[/red]")
                continue

            # Parse and execute command
            args = text.split()
            if len(args) < 1:
                continue

            tag = args[0]

            if tag not in commands:
                console.print(f"[red]Unknown: {tag}[/red] - try 'help'")
                continue

            if len(args) == 1:
                show_help(commands, tag)
                continue

            # Support both orderings:
            #   services start mem0   (command-first, original)
            #   services mem0 start   (resource-first, new)
            second = args[1]
            third = args[2] if len(args) > 2 else None

            # Get cached resources for this group
            completer = session.completer
            resources = completer._get_resources(tag) if hasattr(completer, '_get_resources') else []

            # Determine command and resource based on what was typed
            if second in commands[tag]:
                # Command-first: services start mem0
                cmd_name = second
                cmd_info = commands[tag][cmd_name]
                remaining = args[2:]
            elif second in resources and third and third in commands[tag]:
                # Resource-first: services mem0 start
                cmd_name = third
                cmd_info = commands[tag][cmd_name]
                # Pre-fill the resource as the first path param
                remaining = [second] + args[3:]
            elif second in resources:
                # Just resource, no command yet: services mem0
                console.print(f"[yellow]Select a command for {second}:[/yellow]")
                resource_cmds = [c for c, i in commands[tag].items() if i.get("path_params")]
                console.print(f"[dim]{', '.join(sorted(resource_cmds))}[/dim]")
                continue
            else:
                console.print(f"[red]Unknown: {tag} {second}[/red]")
                console.print(f"[dim]Available commands: {', '.join(sorted(commands[tag].keys()))}[/dim]")
                continue

            # Parse path parameters
            path_args = {}
            for param in cmd_info["path_params"]:
                if not remaining:
                    console.print(f"[red]Missing: <{param}>[/red]")
                    continue
                path_args[param] = remaining.pop(0)

            # Parse query parameters
            query_args = {}
            body_data = None
            i = 0
            while i < len(remaining):
                arg = remaining[i]
                if arg.startswith("--"):
                    param_name = arg[2:]
                    if i + 1 < len(remaining) and not remaining[i + 1].startswith("-"):
                        query_args[param_name] = remaining[i + 1]
                        i += 2
                    else:
                        query_args[param_name] = True
                        i += 1
                elif arg in ("--data", "-d") and i + 1 < len(remaining):
                    try:
                        body_data = json.loads(remaining[i + 1])
                    except json.JSONDecodeError as e:
                        console.print(f"[red]Invalid JSON: {e}[/red]")
                    i += 2
                else:
                    i += 1

            # Execute
            try:
                result = execute_command(client, cmd_info, path_args, query_args, body_data, tag, cmd_name)
                print_result(result, tag, cmd_name)
            except Exception as e:
                console.print(f"[red]Error: {e}[/red]")

        except KeyboardInterrupt:
            console.print("\n[dim]Ctrl+C - type 'exit' to quit[/dim]")
        except EOFError:
            console.print("\n[dim]Goodbye![/dim]")
            break


def main():
    """Main CLI entry point."""
    # Load and parse OpenAPI spec
    spec = load_openapi_spec()
    commands = parse_endpoints(spec)

    # Parse arguments
    args = sys.argv[1:]

    # No arguments - show help
    if not args:
        show_help(commands)
        return

    # Handle special commands
    if args[0] in ("--help", "-h", "help"):
        show_help(commands)
        return

    if args[0] == "health":
        try:
            client = UshadowClient.from_env()
            result = client.health()
            console.print("[green]‚úÖ ushadow backend healthy[/green]")
            if "--verbose" in args or "-v" in args:
                console.print(json.dumps(result, indent=2))
        except Exception as e:
            console.print(f"[red]‚ùå Backend unreachable: {e}[/red]")
            sys.exit(1)
        return

    if args[0] == "shell":
        try:
            client = UshadowClient.from_env()
            run_shell(commands, client)
        except Exception as e:
            console.print(f"[red]‚ùå Cannot start shell: {e}[/red]")
            sys.exit(1)
        return

    # Get command group
    tag = args[0]

    if tag not in commands:
        console.print(f"[red]Unknown command group: {tag}[/red]")
        console.print(f"[dim]Available: {', '.join(sorted(commands.keys()))}[/dim]")
        sys.exit(1)

    # Help for command group
    if len(args) == 1 or args[1] in ("--help", "-h", "help"):
        show_help(commands, tag)
        return

    # Get command
    cmd_name = args[1]

    if cmd_name not in commands[tag]:
        console.print(f"[red]Unknown command: {tag} {cmd_name}[/red]")
        console.print(f"[dim]Available: {', '.join(sorted(commands[tag].keys()))}[/dim]")
        sys.exit(1)

    cmd_info = commands[tag][cmd_name]
    remaining_args = args[2:]

    # Parse path parameters (positional)
    path_args = {}
    for param in cmd_info["path_params"]:
        if not remaining_args:
            console.print(f"[red]Missing required argument: <{param}>[/red]")
            console.print(f"[dim]Usage: ush {tag} {cmd_name} <{param}>[/dim]")
            sys.exit(1)
        path_args[param] = remaining_args.pop(0)

    # Parse query parameters and options
    query_args = {}
    body_data = None
    verbose = False

    i = 0
    while i < len(remaining_args):
        arg = remaining_args[i]

        if arg in ("--verbose", "-v"):
            verbose = True
            i += 1
        elif arg in ("--data", "-d") and i + 1 < len(remaining_args):
            try:
                body_data = json.loads(remaining_args[i + 1])
            except json.JSONDecodeError as e:
                console.print(f"[red]Invalid JSON: {e}[/red]")
                sys.exit(1)
            i += 2
        elif arg.startswith("--"):
            # Query parameter
            param_name = arg[2:]
            if i + 1 < len(remaining_args) and not remaining_args[i + 1].startswith("-"):
                query_args[param_name] = remaining_args[i + 1]
                i += 2
            else:
                query_args[param_name] = True
                i += 1
        else:
            console.print(f"[yellow]Warning: Unexpected argument: {arg}[/yellow]")
            i += 1

    # Execute command
    try:
        client = UshadowClient.from_env(verbose=verbose)

        if verbose:
            console.print(f"[dim]üîó {cmd_info['method']} {cmd_info['path']}[/dim]")

        result = execute_command(
            client, cmd_info, path_args, query_args, body_data, tag, cmd_name
        )

        print_result(result, tag, cmd_name)

    except Exception as e:
        console.print(f"[red]‚ùå Error: {e}[/red]")
        sys.exit(1)


if __name__ == "__main__":
    main()
